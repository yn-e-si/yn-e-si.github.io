---
title: "[Programmers Dev] lv1_체육복 "
excerpt: "어서와! 자료구조와 알고리즘은 처음이지?"
toc: true
toc_sticky: true
categories:
 - CS
tags:
 - 프로그래머스
 - 자료구조
 - 알고리즘
 - 문제풀이
use_math: true
---

## &#128161; 탐욕법: 

[[문제 출처]](https://programmers.co.kr/learn/courses/30/lessons/42862)

### &#128204; 문제 설명

- 체육복을 도난당한 학생들에게 여벌 체육복이 있는 학생이 체육복을 빌려주려 합니다.
- 앞 번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다.
- 전체 학생의 수 $n$, 체육복을 도난당한 학생들의 번호가 담긴 배열 $lost$, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 $reserve$ 가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.

### &#128204; 제한 사항

- 전체 학생의 수는 2 명 이상 30 명 이하입니다.
- 체육복을 도난당한 학생의 수와 여벌의 체육복을 가져온 학생의 수는 1 명 이상 n 명 이하이고 중복되는 번호는 없습니다.

### &#128204; 문제 분석

- 빌려줄 학생들을 <code>정해진 순서</code> 로 살펴야 하고, 이 <code>정해진 순서</code> 에 따라 우선하여 빌려줄 방향을 정해야 하므로 탐욕법 알고리즘임을 예상할 수 있다.

### &#128204; 알고리즘 설계

방법 1 - 학생의 수는 최대 30 명이라는 점에 착안

- 학생 수만큼 배열을 확보하고, 여기에 각자가 가지고 있는 체육복의 수를 기록한다.
- 번호 순서대로 <code>스캔</code> 하면서 빌려줄 관계를 정한다.

- 이 때, 코드 구현의 편의성을 위해서 list 의 맨 앞과 맨 뒤에 1을 하나씩 추가한다.
- 시간복잡도: $O(n)$

> &#128173; 여벌을 가져온 학생 처리: <code>reserve</code> 의 길이에 비례, 체육복을 잃어버린 학생 처리: <code>lost</code> 의 길이에 비례, 체육복 빌려주기 처리: 전체 학생 수 <code>n</code> 에 비례

<br/>

방법 2 - 만약 전체 학생 수 <code>n</code> 이 클 때, 여벌의 체육복을 가져온 학생은 매우 적다면,,,

- 여벌의 체육복을 가져온학생들의 번호 <code>reserve</code>  를 정렬한다.
- 순서대로 살펴보면서 빌려줄 수 있는 다른 학생을 찾아서 처리한다.
- 이 때, 해시를 사용해서 처리한다.
- 시간복잡도: $O(klogk)$

> &#128173; 여벌의 체육복을 가져온 학생들의 번호를 정렬하므로 이는 학생의 수가 많고 여벌의 체육복을 가져온 학생이 적을 때 사용하면 방법 1 보다 유리하다.
>
> &#128173; 단, $n$ 이 크지않거나 $n$ 이나 $k$ 가 비슷한 수라면 방법 2 보다 방법 1이 유리하다.

### &#128204; 코드 구현

```python
# 방법 1
def solution(n, lost, reserve):
	u = [1] * (n + 2) # 모든 원소를 1로 초기화하는데 맨 앞과 맨 뒤를 추가
    
	for i in reserve: # 여벌이 있는 학생들은 +1
		u[i] += 1   # -> 복잡도: O(n)
        
	for i in lost: # 잃어버린 학생들은 -1
		u[i] -= 1 # -> 복잡도: O(n)
        
	for i in range(1, n+1): 
		if u[i - 1] == 0 and u[i] == 2: # 앞 번호가 잃어버렸을 때 빌려주는 경우
			u[i - 1: i + 1] = [1, 1] # i-1 과 i 학생을 1로 만들어 주는 것
            
		elif u[i] == 2 and u [i + 1] == 0:
			u[i: i+2] = [1, 1] # i와 i+1 학생을 1로 만들어 줌
            
	return len([x for x in u[1:-1] if x > 0]) 
```

```python
# 방법 2
방법[2]
def solution(n, lost, reserve):
	s = set(lost) & set(reserve) # 두 집합의 교집합을 의미
	l = set(lost) - s # 체육복을 도난당했지만 빌릴필요가 없는 학생들을 제외한 빌려야하는 학생들
	r = set(reserve) - s # 여벌의 체육복을 가져와서 빌려줄 수 있는 학생들
	for x in sorted(r):
        
		if x - 1 in l: # 조건문의 순서가 중요함!
			l.remove(x - 1)
            
		elif x + 1 in l:
			l.remove(x + 1)
	return n - len(l)
```





## &#128161; Check Point

- 같은 탐욕법 알고리즘이라도 문제의 제한 사항에 따라 시간복잡도를 보다 유리하게 만들 수 있으므로 항상 효율성을 생각하고 알고리즘을 풀어나가야 할 것 같다.