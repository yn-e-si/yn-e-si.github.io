---
title: "[Programmers Dev] 수식의 후위 표기법 "
excerpt: "어서와! 자료구조와 알고리즘은 처음이지?"
toc: true
toc_sticky: true
categories:
 - CS
tags:
 - 프로그래머스
 - 자료구조
 - 알고리즘
---

## 스택의 응용 - 수식의 후위 표기법

### 중위 표기법과 후위 표기법

중위 표기법 (infix notation)

: 연산자가 피연산자들의 **사이**에 위치 

> (A + B) * (C + D)



후위 표기법 (postfix notation)

: 연산자가 피연산자들의 **뒤**에 위치

> A B + C D + *



### 중위 표현식 -> 후위 표현식

: Stack 을 사용함으로써 연산자들의 우선순위를 지키면서 구현할 수 있다.

- Stack 에는 아직 행하지 않은 연산자들이 들어가게 된다.
- 피연산자는 그냥 출력하고 연산자는 연산자끼리 우선순위를 비교한다.
- Stack 의 top 에 있는 연산자의 우선순위가 높거나 같은결우 pop 을 하고 출력한다.
- top 에 있는 연산자의 우선순위가 낮다면 현재 연산자를 Stack 에 push 한다.

> 1. [중위] A * B + C  	[후위] A B * C +
> 2. [중위] A + B * C      [후위] A B C * +



1. A * B + C 	->	A B * C +

(1) 피연산자는 그냥 둔다. -> [A]

(2) 연산자를 만나면 Stack 에 push 한다. -> S = [''*'']

(3) 피연산자는 그냥 둔다. -> [B]

(4) 연산자를 만났지만 Stack 이 비어있지 않으므로 Stack 의 top 과 현재 연산자의

​	 우선순위를 비교한다. -> ''*'' > ''+''

(5) top 위치의 연산자가 우선순위가 높기에 pop 하고 append 한다. -> [A, B, ''*''], S = [ ]

(6) 다음의 연산자를 다시 Stack 에 push 한다. -> [A, B, "*"], S = ["+"]

(7) 피연산자를 만났기에 그냥 둔다. -> [A, B, "*", C]

(8) 수식에 끝까지 왔고 Stack 에 남아있는 것은 아직 행하지 않은 연산이기에

​	 pop 해서 끝에 붙인다. -> [A, B, "*", C, "+"], S = [ ]



2. A + B * C → A B C * +

(1) 피연산자는 그냥 둔다. → [A]

(2) 연산자를 만나면 Stack에 push 한다. → S = [''+'']

(3) 피연산자는 그냥 둔다. → [A, B]

(4) 연산자를 만났지만 Stack이 비어있지 않으므로 Stack의 top과 현재 연산자의

​	 우선순위를 비교한다. → "+'' < ''*''

(5) top 위치의 연산자가 우선순위가 낮기에 현재 연산자를 Stack에 push 한다. → S = ["+'',"*"]

(6) 피연산자는 그냥 둔다. → [A, B, C]

(7) 수식에 끝까지 왔으므로 다시 Stack에 들어있는 연산자들을 pop 해서 append한다.

​	  → [A, B, C, ''\*''], S = [''+''] 

​	 → [A, B, C, "*", ''+''] , S = [ ]



### 괄호의 처리

- 여는 괄호를 만나면 stack 에 push 한다.

- 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop 을 진행한다.

- 연산자를 만났을 때, 여는 괄호 너머까지 pop 하지 않도록 여는 괄호의

   우선순위는 가장 낮게 설정한다.

  -> ex. [중위] A * (B + C)	[후위] A B C + *